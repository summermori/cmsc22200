Overview:

	check_branch_ahead(addr)
	{
		uint64_t base = CURRENT_STATE.PC - 4;
		int64_t offset;

		//cond
		if (IDtoEX.op == 0x54000000)
		{
			int64_t cond = IDtoEX.dnum;
			offset = IDtoEX.addr >> 5;
			//check if it is branching
			switch(cond)
			{
				//BEQ
				case(0):
					if (Control.fz == 1)
					{
						if ((base + offset) == addr)
						{
							return 0;
						}
						else
						{
							return 1;
						}
					}
					else
					{
						return 0;
					}
				//BNE
				case(1):
					if (Control.fz == 0)
					{
						if ((base + offset) == addr)
						{
							return 0;
						}
						else
						{
							return 1;
						}
					}
					else
					{
						return 0;
					}
				//BGE
				case(10):
					if ((Control.fz == 1) || (Control.fn == 0))
					{
						if ((base + offset) == addr)
						{
							return 0;
						}
						else
						{
							return 1;
						}
					}
					else
					{
						return 0;
					}
				//BLT
				case(11):
					if ((Control.fn == 1) || (Control.fz == 0))
					{
						if ((base + offset) == addr)
						{
							return 0;
						}
						else
						{
							return 1;
						}
					}
					else
					{
						return 0;
					}
				//BGT
				case(12):
					if ((Control.fz == 0) || (Control.fn == 0))
					{
						if ((base + offset) == addr)
						{
							return 0;
						}
						else
						{
							return 1;
						}
					}
					else
					{
						return 0;
					}
				//BLE 
				case(13):
					if ((Control.fz == 1) || (Control.fn == 1))
					{
						if ((base + offset) == addr)
						{
							return 0;
						}
						else
						{
							return 1;
						}
					}
					else
					{
						return 0;
					}
			}

		}
		//uncond reg 
		if (IDtoEX.op == 0xd61f0000)
		{
			int64_t target;
			if (EXtoMEM.dnum == IDtoEX.n)
			{
				target = EXtoMEM.res;
			}
			else
			{
				target = CURRENT_STATE.REGS[IDtoEX.n];
			}

			if (target == addr)
			{
				return 0;
			}
			else
			{
				return 1;
			}
		}

		//uncond imm
		if (IDtoEX.op == 0x14000000)
		{
			offset = IDtoEX.addr;
			if ((base + offset) == addr)
			{
				return 0;
			}
			else
			{
				return 1;
			}
		}

		//CBZ
		if (IDtoEX.op == 0xb4000000)
		{
			offset = IDtoEX.addr/32;
			int reg_load_ahead = 0;
			switch(ExtoMEM.op)
			{
				// Add/Subtract immediate
				case 0x91000000:
				//printf("ADD\n");
				reg_load_ahead = 1;
				break;
				case 0xb1000000:
				//printf("ADDS\n");
				reg_load_ahead = 1;
				break;
				case 0xd1000000:
				// printf("SUB\n");
				reg_load_ahead = 1;
				break;
				case 0xf1000000:
				// printf("SUBS\n");
				reg_load_ahead = 1;
				break;
				// Compare and branch
				case 0xb4000000:
				//printf("CBZ\n");
				break;
				case 0xb5000000:
				//printf("CBNZ\n");
				break;
				// Move wide
				case 0xd2800000:
				//printf("MOVZ\n");
				reg_load_ahead = 1;
				break;
				// Bitfield
				case 0xd3000000:
				//printf("LSL or LSR\n"); //execution has to do the distinction
				break;
				// Conditional branch
				case 0x54000000:
				//printf("B.cond\n");
				break;
				// Exceptions
				case 0xd4400000:
				//printf("HLT\n");
				break;
				// Unconditional branch (register)
				case 0xd61f0000:
				//printf("BR\n");
				break;
				// Unconditional branch (immediate)
				case 0x14000000:
				//printf("B\n");
				break;

				// Logical (shifted register)
				case 0x8a000000:
				//printf("AND\n");
				reg_load_ahead = 1;
				break;
				case 0xea000000:
				//printf("ANDS\n");
				reg_load_ahead = 1;
				break;
				case 0xca000000:
				//printf("EOR\n");
				reg_load_ahead = 1;
				break;
				case 0xaa000000:
				//printf("ORR\n");
				reg_load_ahead = 1;
				break;
				// Add/subtract (extended)
				case 0x8b000000:
				//printf("ADD\n");
				reg_load_ahead = 1;
				break;
				case 0xab000000:
				//printf("ADDS\n");
				reg_load_ahead = 1;
				break;
				case 0xcb000000:
				//printf("SUB\n");
				reg_load_ahead = 1;
				break;
				case 0xeb000000:
				//printf("SUBS\n");
				reg_load_ahead = 1;
				break;
				// Data Processing (3 source)
				case 0x9b000000:
				//printf("MUL\n");
				reg_load_ahead = 1;
				break;
			}
			if (((EXtoMEM.dnum == IDtoEX.dnum) && (EXtoMEM.res == 0) && (reg_load_ahead == 1)))
			{
				if ((base + offset) == addr)
				{
					return 0;
				}
				else
				{
					return 1;
				}
			}
			else if (((EXtoMEM.dnum == IDtoEX.dnum) && (EXtoMEM.res != 0) && (reg_load_ahead == 1)))
			{
				return 0;
			}
			else if (CURRENT_STATE.REGS[IDtoEX.dnum] == 0)
			{
				if ((base + offset) == addr)
				{
					return 0;
				}
				else
				{
					return 1;
				}
			}
			else
			{
				return 0;
			}


		}
		//CBNZ
		if (IDtoEX.op == 0xb5000000)
		{
			offset = IDtoEX.addr/32;
			int reg_load_ahead = 0;
			switch(ExtoMEM.op)
			{
				// Add/Subtract immediate
				case 0x91000000:
				//printf("ADD\n");
				reg_load_ahead = 1;
				break;
				case 0xb1000000:
				//printf("ADDS\n");
				reg_load_ahead = 1;
				break;
				case 0xd1000000:
				// printf("SUB\n");
				reg_load_ahead = 1;
				break;
				case 0xf1000000:
				// printf("SUBS\n");
				reg_load_ahead = 1;
				break;
				// Compare and branch
				case 0xb4000000:
				//printf("CBZ\n");
				break;
				case 0xb5000000:
				//printf("CBNZ\n");
				break;
				// Move wide
				case 0xd2800000:
				//printf("MOVZ\n");
				reg_load_ahead = 1;
				break;
				// Bitfield
				case 0xd3000000:
				//printf("LSL or LSR\n"); //execution has to do the distinction
				break;
				// Conditional branch
				case 0x54000000:
				//printf("B.cond\n");
				break;
				// Exceptions
				case 0xd4400000:
				//printf("HLT\n");
				break;
				// Unconditional branch (register)
				case 0xd61f0000:
				//printf("BR\n");
				break;
				// Unconditional branch (immediate)
				case 0x14000000:
				//printf("B\n");
				break;

				// Logical (shifted register)
				case 0x8a000000:
				//printf("AND\n");
				reg_load_ahead = 1;
				break;
				case 0xea000000:
				//printf("ANDS\n");
				reg_load_ahead = 1;
				break;
				case 0xca000000:
				//printf("EOR\n");
				reg_load_ahead = 1;
				break;
				case 0xaa000000:
				//printf("ORR\n");
				reg_load_ahead = 1;
				break;
				// Add/subtract (extended)
				case 0x8b000000:
				//printf("ADD\n");
				reg_load_ahead = 1;
				break;
				case 0xab000000:
				//printf("ADDS\n");
				reg_load_ahead = 1;
				break;
				case 0xcb000000:
				//printf("SUB\n");
				reg_load_ahead = 1;
				break;
				case 0xeb000000:
				//printf("SUBS\n");
				reg_load_ahead = 1;
				break;
				// Data Processing (3 source)
				case 0x9b000000:
				//printf("MUL\n");
				reg_load_ahead = 1;
				break;
			}
			if (((EXtoMEM.dnum == IDtoEX.dnum) && (EXtoMEM.res != 0) && (reg_load_ahead == 1)))
			{
				if ((base + offset) == addr)
				{
					return 0;
				}
				else
				{
					return 1;
				}
			}
			else if (((EXtoMEM.dnum == IDtoEX.dnum) && (EXtoMEM.res == 0) && (reg_load_ahead == 1)))
			{
				return 0;
			}
			else if (CURRENT_STATE.REGS[IDtoEX.dnum] == 0)
			{
				if ((base + offset) == addr)
				{
					return 0;
				}
				else
				{
					return 1;
				}
			}
			else
			{
				return 0;
			}
		}
	}


	cache_read(addr, n) //cache_read takes the read location and the associativity, and returns a uint_32 from either memory or the cache

		if (n == 4) { //condition to establish we are in the instruction cache
			tag = {addr bits 31-11}		//the tag used for matching instruction blocks
			index = {addr bits 10-5}		//the specific set for the instruction
			cache = {global var for i_cache}
		}
		else {
			tag = {addr bits 31-13}		//the tag used for matching data blocks
			index = {addr bits 12-5}		//the specific set for the data
			cache = {global var for d_cache}
		}

		offset = {addr bits 4-0}		//the specific segment of the matching block

		head = (index * n)
		tail = (head + n)

		//declaring variables ahead of time to track the lru mins during the for loop
		min_i = 0
		min_val = MAX_INT

		empty = -1
		
		//go through each of the blocks of the set. If you find a match, update the lru and return
		for (int i = head; i < tail; i++) {
			spec_block = cache[i]

			//prepare data for loading into an empty block or eviction
			if (spec_block.empty) {
				empty = i
			}
			elif (spec_block.lru < min_val) {
				min_i = i
				min_val = spec_block.lru
			}

			if (spec_block.valid && spec_block.tag == tag) {
				spec_block.lru = {global cycle count var}
				return spec_block.data[offset]
			}
		}

		//a miss has occured - different steps here for different caches:

		//if this is the instruction cache AND there is an upcoming branch AND that branch is not to this addr:
		//check_branch_ahead returns 1 if branching in decode and branching to a diff target than addr.
		if (n == 4 && check_branch_ahead(addr) == 1) {
			return 0;
		}

		//we are now guaranteed to be doing a read, and so we can signal the stall dependent on the type of miss
		if (n == 4)
		{
			Control.inst_cache_bubble = 51;
		}
		else
		{
			Control.data_cache_bubble = 51;
		}

		//check if there's an empty block. If so, we load into there
		if (empty != -1) {
			new_block = cache[empty]

			//load in all the variables
			new_block.tag = tag
			new_block.valid = 1
			new_block.lru = {global cycle count var}

			//calculate the "offset-less" addr value, then grab all valid blocks with that head - see note
			addr_head = (addr / 32) * 32
			for (int i = 0; i < 8; i++) {
				new_block.data[i] = mem_read_32(addr_head + (4 * i))
			}

			//return the newly-read address
			return new_block.data[offset]
		}
		//if there isn't, we must evict, which is handled differently if the dirty bit is 1 AND n == 8
		else {
			lru_block = cache[min_i]
			if (lru_block.dirty && (n == 8)) {
				write_base = {the offset-less head, assembled with bitstuff as {tag ^ index ^ 00000}}
				for (int i = 0; i < 8; i++) {
					mem_write_32((write_base + (i * 4)), lru_block.data[i])
				}
				lru_block.dirty = 0
			}

			lru_block.tag = tag
			lru_block.lru = {global cycle count var}

			addr_head = (addr / 32) * 32
			for (int i = 0; i < 8; i++) {
				lru_block.data[i] = mem_read_32(addr_head + (4 * i))
			}

			//return the newly-read address
			return lru_block.data[offset];
		}




NOTE 1 - "Offset-less head"

	The system is set up so that you read the ENTIRE 32-byte section signified by the first 27 bits, then use the 5-bit offset to pull the specific 4-byte section out

	This is how matching works - if you have a matching tag and index, you MUST have the data in the block, meaning that the block logically must contain ALL possible data that begins with the prefix {tag + index}.

	For example, if you have the hypothetical address 0x8FC, let us assume that "1000111" is the {tag + index} and therefore "11100" is the offset. Inside of the "1000111" block, you must have all the possible permutations of the offset (which is simplified for us because we know that the system is byte-addressable by 4, and thus the offset must be a multiple of 4 - this is why the PC increments by 4). 
	
	In order to ensure that the block has all the valid segments, we thus must do 8 reads - one for each of the 4-word reads that could be made with the prefix "1000111". The suffixes for these reads are listed below:

	00000
	00100
	01000
	01100
	10000
	10100
	11000
	11100

	As a corollary, we must also repeat this process when writing back

NOTE 2 - Integration
	
	The code described above is very neatly encapsulated in one function, which in turn only needs to be called in two places: 
		-Once in the Fetch stage, replacing the "mem_read_32" call we currently use
		-In the Memory stage, replacing the "mem_read_32" calls as appropriate

	The two main hiccups to full integration are as follows:
		-Getting the stall functionality working correctly after a "cache_read" call miss
		-Writing a separate "cache_write" function to be used for Memory operations attempting to write to an address.

NOTE 3 - "cache_write"

	cache_write (addr, val) {

		tag = {addr bits 31-13}		//the tag used for matching data blocks
		index = {addr bits 12-5}		//the specific set for the data
		offset = {addr bits 4-0}		//the specific segment of the matching block

		head = (index * n)
		tail = (head + n)

		//declaring variables ahead of time to track the lru mins during the for loop
		min_i = 0
		min_val = MAX_INT

		empty = -1
		
		//go through each of the blocks of the set. If you find a match, update the lru and return
		for (int i = head; i < tail; i++) {
			spec_block = cache[i]

			//prepare data for loading into an empty block or eviction
			if (spec_block.empty) {
				empty = i
			}
			elif (spec_block.lru < min_val) {
				min_i = i
				min_val = spec_block.lru
			}

			if (spec_block.valid && spec_block.tag == tag) {
				spec_block.lru = {global cycle count var}
				spec_block.dirty = 1
				spec_block.data[offset] = val
			}
		}

		//a miss has occured, and as such we have to read in the correct block.
		{stall_signal for 50 cycles}

		//check if there's an empty block. If so, we load into there
		if (empty != -1) {
			new_block = cache[empty]

			//load in all the variables
			new_block.tag = tag
			new_block.valid = 1
			new_block.lru = {global cycle count var}

			//calculate the "offset-less" addr value, then grab all valid blocks with that head - see note
			addr_head = (addr / 32) * 32
			for (int i = 0; i < 8; i++) {
				new_block.data[i] = mem_read_32(addr_head + (4 * i))
			}

			//write in the value to the correct segment
			new_block.data[offset] = val
		}
		//if there isn't, we must evict, which is handled differently if the dirty bit is 1
		else {
			lru_block = cache[min_i]
			if (lru_block.dirty) {
				write_base = {the offset-less head, assembled with bitstuff as {tag ^ index ^ 00000}}
				for (int i = 0; i < 8; i++) {
					mem_write_32((write_base + (i * 4)), lru_block.data[i])
				}
			}

			lru_block.tag = tag
			lru_block.lru = {global cycle count var}

			addr_head = (addr / 32) * 32
			for (int i = 0; i < 8; i++) {
				lru_block.data[i] = mem_read_32(addr_head + (4 * i))
			}

			//write in the value to the correct segment
			lru_block.dirty = 1
			lru_block.data[offset] = val;
		}
	}